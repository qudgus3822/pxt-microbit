{
  "flashlog": "Storing structured data in flash.",
  "flashlog.beginRow": "Creates a new row in the log, ready to be populated by logData()",
  "flashlog.clear": "Resets all data stored in persistent storage.",
  "flashlog.endRow": "Complete a row in the log, and pushes to persistent storage.",
  "flashlog.getNumberOfRows": "Number of rows currently used by the datalogger, start counting at fromRowIndex\nTreats the header as the first row\n\n@returns header + rows",
  "flashlog.getNumberOfRows|param|fromRowIndex": "0-based index of start: Default value of 0",
  "flashlog.getRows": "Get all rows separated by a newline & each column separated by a comma.\nStarting at the 0-based index fromRowIndex & counting inclusively until nRows.\n\n\n@returns String where newlines denote rows & commas denote columns",
  "flashlog.getRows|param|fromRowIndex": "0-based index of start",
  "flashlog.getRows|param|nRows": "inclusive count from fromRowIndex",
  "flashlog.logData": "Populates the current row with the given key/value pair.",
  "flashlog.logString": "Inject the given row into the log as text, ignoring key/value pairs.",
  "flashlog.setSerialMirroring": "Defines if data logging should also be streamed over the serial port.\n* @param enable True to enable serial port streaming, false to disable.",
  "flashlog.setTimeStamp": "Determines the format of the timestamp data to be added (if any).\nIf requested, time stamps will be automatically added to each row of data\nas an integer value rounded down to the unit specified.\n* @param format The format of timestamp to use."
}